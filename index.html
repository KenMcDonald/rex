<!DOCTYPE HTML>
		<html>
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<style media="screen" type="text/css">

		.underline { text-decoration: underline; }

.tableCaption {
	display: table-caption;
	font-size: 12pt;
	background-color: #DDD;
	padding: 5px;
}

.inset {
	margin-left: 3em;
	margin-right: 3em;
}

.block { display: block; }

.leftNote {
	background-color: #EEE;
	float: left;
	width: 1.5in;
	font-family: serif;
	font-size: 10pt;
	padding: 0.5em;
	margin: 1em;
	border: 1px solid black;
}

.code-inline {
	font-family:Consolas,'Lucida Sans Typewriter','Lucida Console','DejaVu Sans Mono',monospace;
	font-size: 90%;
	white-space: pre;
	background-color: #EEE;
	display: inline;
}

.code-block {
	font-family:Consolas,'Lucida Sans Typewriter','Lucida Console','DejaVu Sans Mono',monospace;
	font-size: 90%;
	display: block;
	white-space: pre;
	margin: 1.5em;
	padding: 0.5em;
	border: 1px solid #888;
	line-height: 1.5;
	overflow: auto;
}

.note {
	display: block;
	margin: 2em;
}

.pre { white-space: pre; }

.nonterminal {
	font-family: serif;
	font-style: italic;
	font-weight: bold;
}

.table {
	display: table;
	width:90%;
	border-bottom: 1px solid #DDD;
}

.row {
	display: table-row;
	margin: 0px;
	padding: 0px;
}

.namecell {
	display: table-cell;
	border-top: 1px solid #DDD;
	padding: 5px;
	width: 10%;
	font-weight: bold;
	margin: 0;
}

.desccell {
	padding: 5px;
	border-top: 1px solid #DDD;
	width: 80%;
	margin: 0;
}

.cell {
	display: table-cell;
	border-top: 1px solid #DDD;
	padding: 5px;
	margin: 0;
}

.w10 { width: 10%; }
.w20 { width: 20%; }
.w30 { width: 30%; }
.w50 { width: 50%; }
.w80 { width: 80%; }

.descriptionsTitle {
   display: block;
   padding: 8px;
   font-size: 12pt;
   background: #DDD;
   margin-top: 1em;
}

dl.returnsDescription {
	float: left;
	width: 100%;
	padding: 0;
	border: 1px solid #DDD;
	clear: right;
	overflow: auto;
}

.returnsDescription dt {
	clear: left;
	float: left;
	padding: 5px;
	padding-right: 15px;
   font-size: 12pt;
   background: #DDD;
}

.returnsDescription dd {
	float: left;
	width: 70%;
	padding: 5px;
	margin-left; 5px;
}

dl.returnsDescription dd p {
	margin-bottom: 5px;
}

p {
   margin: 1.33em 0
}
ul p, ol p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}
ul, ol {
   display: block;
   margin-bottom: 1.33em;
}
ul li, ol li {
	margin-bottom: 1em;
}
th {
   font-weight: bold;
   text-align: center
}
caption {
   text-align: center
}

blockquote {
   display: block;
   margin-left: 40px;
   margin-right: 40px
}

body {
   display: block;
   padding: 8px;
   font-family: sans-serif;
   font-size: 11pt;
   counter-reset: mynum-h1;
   counter-reset: h1-toc-counter;
}

.h1-toc {
	margin-top: 1em;
	display: block;
	font-size: 1.2;
	font-weight: bold;
}

.h2-toc {
	display: block;
	margin-top: 0.5em;
	margin-left: 1.0em;
	font-size: 1.2;
}

.h3-toc {
	display: block;
	margin-left: 2.0em;
	font-style: italic;
}

.h4-toc {
	margin-left: 3.0em;
	display: block;
}

.scalaKeyword { font-weight: bold; }
.scalaString { color: green; }
.scalaLineComment { color: #A00; }
.scalaBlockComment { color: #A00; }
.scalaCharacter { color: blue; }
dl { margin-right: 2em; margin-left: 2em; }
dt {font-weight: bold; }
dd {  margin-bottom: 0.5em;}

.bold {font-weight: bold; }


		</style>
		</head>
		<body>
		<a class="h1-toc" href="#1">Introduction to the Rex Package</a><a class="h1-toc" href="#2">Summary of Rex</a><a class="h1-toc" href="#3">Using Rex in Your Program</a><a class="h2-toc" href="#4">Download Rex and Put It on Your Classpath</a><a class="h2-toc" href="#5">Import Rex Into Your Code</a><a class="h1-toc" href="#6">Rex Basics: Literal Patterns and the Match and Occurs Operators</a><a class="h1-toc" href="#7">Building Rex Patterns</a><a class="h2-toc" href="#8">Rex Literals </a><a class="h2-toc" href="#9">Character Classes</a><a class="h3-toc" href="#10">Basic Ways to Define Character Classes.</a><a class="h3-toc" href="#11">Predefined Character Classes</a><a class="h3-toc" href="#12">Character Class Extensions</a><a class="h3-toc" href="#13">Negated Character Classes</a><a class="h3-toc" href="#14">Character Class Instersection and Subtraction</a><a class="h2-toc" href="#15">Repetition Operators</a><a class="h3-toc" href="#16">Repetition Operator Basics</a><a class="h3-toc" href="#17">Repetition Strategies</a><a class="h3-toc" href="#18">The Optional Operator</a><a class="h2-toc" href="#19">Concatenation Operators</a><a class="h3-toc" href="#20">Convenience Concatenation Operators</a><a class="h2-toc" href="#21">The Alternation Operator</a><a class="h2-toc" href="#22">Lookahead and Lookback Assertions</a><a class="h3-toc" href="#23">Negative Lookahead/Lookback Assertions</a><a class="h3-toc" href="#24">Restrictions on Lookahead/Lookback Assertions</a><a class="h2-toc" href="#25">Back-References</a><a class="h2-toc" href="#26">Flags</a><a class="h1-toc" href="#27">Processing Text with Rex Patterns</a><a class="h2-toc" href="#28">Extracting Sections of Input Using Named Patterns</a><a class="h2-toc" href="#29">Avoiding Name Clashes with Hierarchical Names</a><a class="h2-toc" href="#30">Processing All Matches in an Input String</a><a class="h2-toc" href="#31">Simple String Replacement</a><a class="h2-toc" href="#32">The Tokenizer Class</a>
		<h1><a name="1"></a>Introduction to the Rex Package</h1><p/>Regular expressions are incredibly powerful tools when dealing with any sort of textual information. Unfortunately, they
are also somewhat arcane, and difficult to debug. Rex (the full package name is 'com.digitaldoodles.rex') intends to change that.<p/>Rex has several goals:<p/><ol><li>Allow regular expressions to be built and tested in small units, and then easily assembled into larger
units. This is simply good software engineering practice, but is surprisingly difficult to achieve with
standard regex packages.</li><li>Instead of requiring users to learn an arcane regular expression language that often resembles line noise,
allow them to create regular expressions using standard methods, operators, and other tools of Scala,
and do so in such a manner that the resultant regex is much easier to read than one written directly in a
&quot;regex language&quot;. This also means that standard IDEs can provide a great deal of contextual help.</li><li>Allow groups to be named when they are defined in a regex, and allow matches to those groups
to be accessed by their names. This is different from Scala, where the onus is on the programmer to ensure
that (if provided) a list of group names correctly corresponds to the parentheses
in a regular expression.</li><li>Provide a more flexible mechanism for iterating through the results of a regex
search. In particular, when a regular expression is used to iterate
over a target string, it should be possible to obtain not just the parts of the string that
matched, but also the parts that didn't, as this is often useful.</li><li>Provide useful predefined regular expressions that users can easily incorporate into their own code.</li></ol><p/>Before becoming more formal, let me give you an example of how rex makes it
easy to build complex regular expressions from simpler ones. Here's how to build
a regular expression that recognizes complex numbers:<p/><div class="code-block"><span class="scalaLineComment">// *&gt;1 means 1 or more, greedily (as many times as possible.)
</span><span class="scalaKeyword">val</span> posInt = CharRange(<span class="scalaCharacter">'0'</span>,<span class="scalaCharacter">'9'</span>)*&gt;1
<span class="scalaLineComment">// Lit means literal. The &quot;-&quot; is automatically converted to a literal.
</span><span class="scalaKeyword">val</span> sign = Lit(<span class="scalaString">&quot;+&quot;</span>)|<span class="scalaString">&quot;-&quot;</span>
<span class="scalaLineComment">// +~ represents concatenation, ? means an element is optional.
</span><span class="scalaKeyword">val</span> floatPat = sign.? +~ posInt +~ (Lit(<span class="scalaString">&quot;.&quot;</span>) +~ posInt).?
<span class="scalaLineComment">// &quot;name&quot; creates named groups for extracting information from matches.
</span><span class="scalaKeyword">val</span> complex = floatPat.name(<span class="scalaString">&quot;re&quot;</span>) +~ sign.name(<span class="scalaString">&quot;op&quot;</span>) +~ floatPat.name(<span class="scalaString">&quot;im&quot;</span>) +~ <span class="scalaString">&quot;i&quot;</span>
</div><p/>When the complex pattern is used to find a complex number, the real and imaginary parts,
and operator, can be pulled out of the match result by name: 're', 'im', and 'op'.<p/>Notice how regular expressions in rex can be easily composed, without the necessity of worrying
too much about parentheses or precedence. This is in sharp contrast to trying to build textual regular
expressions manually, from smaller textual regular expressions.<p/>
<h1><a name="2"></a>Summary of Rex</h1><p/>If you are already familiar with regexes, the following summaries may let you start using Rex more quickly. They are
are also a convenient reference once you have learned rex.<p/><div class="table inset"><div class="tableCaption">Rex character class constructors and methods, where <span class="nonterminal">C</span>, <span class="nonterminal">C1</span>, <span class="nonterminal">C2</span>,... are existing Rex character classes.</div>
	<div class="row"><span class="cell w10"><span class="code-inline">CharSet(<em>string</em>)</span></span>
		<span class="cell w80">Will match a single character if that character is in <em>string</em>.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline">CharRange(<em>char1</em>, <em>char</em>)</span></span>
		<span class="cell w80">Will match a single character if that character is in the range <em>char1</em>-<em>char2</em> inclusive.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline">!<span class="nonterminal">C</span></span></span>
		<span class="cell w80">Matches a single character if and only if <span class="nonterminal">C</span> would <em>not</em> match that character.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">C</span>.charRange(<em>char1</em>, <em>char</em>).charSet(<em>string</em>)</span></span>
		<span class="cell w80">Matches the set of characters matched by <span class="nonterminal">C</span> and the characters in the range <em>char1</em>-<em>char2</em>
		and the characters in <em>string</em>. <span class="code-inline">charSet</span> and <span class="code-inline">charRange</span> may be invoked multiple times.
		<div class="note"><span class="bold">Note: </span>If <span class="nonterminal">C</span> is a negated character class, then method invocations of this nature will result in a pattern
		that <em>fails</em> to match the characters in <em>char1</em>-<em>char2</em>
		or in <em>string</em>.</div>
		</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">C</span>.Digit.Punctuation...</span></span>
		<span class="cell w80">Matches the set of characters matched by <span class="nonterminal">C</span> and any digit and any punctuation character; a number of
		 methods are defined that define different character classes.
		<div class="note"><span class="bold">Note: </span>If <span class="nonterminal">C</span> is a negated character class, then method invocations of this nature will result in a pattern
		that <em>fails</em> to match the characters in <em>char1</em>-<em>char2</em>
		or in <em>string</em>.</div>
		</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">C1</span> /\ <span class="nonterminal">C2</span></span></span>
		<span class="cell w80">Matches a single character if and only both <span class="nonterminal">C1</span> and <span class="nonterminal">C2</span> would match that character.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">C1</span> - <span class="nonterminal">C2</span></span></span>
		<span class="cell w80">Matches a single character if it is in <span class="nonterminal">C1</span> and not in <span class="nonterminal">C2</span>.</span>
	</div>
</div><p/><div class="table inset"><div class="tableCaption">Rex general pattern constructors and methods, where <span class="nonterminal">A</span>, <span class="nonterminal">B</span>,... are existing Rex patterns.</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> +~ <span class="nonterminal">B</span></span></span>
		<span class="cell w80">Succeeds if it can first match <span class="nonterminal">A</span>, then match <span class="nonterminal">B</span> starting from where the match to <span class="nonterminal">A</span> ended.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> | <span class="nonterminal">B</span></span></span>
		<span class="cell w80">Succeeds if it can match either <span class="nonterminal">A</span> or <span class="nonterminal">B</span>, starting the current match position.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *&gt; <em>m</em></span></span>
		<span class="cell w80">Succeeds if it can match at least <em>m</em> instances of <span class="nonterminal">A</span>, repeating
		as many times as possible while still having the match succeed.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *&gt; (<em>m</em>, <em>n</em>)</span></span>
		<span class="cell w80">Succeeds if it can match at least <em>m</em> and no more than <em>n</em> instances of <span class="nonterminal">A</span>, repeating
		as many times as possible in this range while still having the match succeed.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *&lt; <em>n</em></span></span>
		<span class="cell w80">Succeeds if it can match <em>n</em> or more instances of <span class="nonterminal">A</span>, repeating as few times as possible
		while still having the match succeed.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *&lt; (<em>m</em>, <em>n</em>)</span></span>
		<span class="cell w80">Succeeds if it can match at least <em>m</em> and no more than <em>n</em> instances of <span class="nonterminal">A</span>, repeating
		as few times as possible in this range while still having the match succeed.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *! <em>m</em></span></span>
		<span class="cell w80">Succeeds if it can match at least <em>m</em> instances of <span class="nonterminal">A</span>, repeating
		as many times as possible regardless of the effect this has on the match.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span> *! (<em>m</em>, <em>n</em>)</span></span>
		<span class="cell w80">Succeeds if it can match at least <em>m</em> and no more than <em>n</em> instances of <span class="nonterminal">A</span>, repeating
		as many times as possible in this range regardless of the effect this has on the match.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span>.&gt;&gt;</span></span>
		<span class="cell w80">Succeeds if <span class="nonterminal">A</span> matches <em>immediately after</em> the current match position. The match position
		is not modified.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span>.!&gt;&gt;</span></span>
		<span class="cell w80">Succeeds if <span class="nonterminal">A</span> fails to match <em>immediately after</em> the current match position. The match position
		is not modified.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span>.&lt;&lt;</span></span>
		<span class="cell w80">Succeeds if <span class="nonterminal">A</span> matches <em>immediately before</em> the current match position. The match position
		is not modified.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">A</span>.!&lt;&lt;</span></span>
		<span class="cell w80">Succeeds if <span class="nonterminal">A</span> fails to match <em>immediately before</em> the current match position. The match position
		is not modified.</span>
	</div>
</div><p/><div class="table inset"><div class="tableCaption">Rex string testing operators, where <span class="nonterminal">M</span> is a Rex pattern.</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span> ~~= <em>string</em></span></span>
		<span class="cell w80">Returns true if <span class="nonterminal">M</span> exactly matches <em>string</em>.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span> !~~= <em>string</em></span></span>
		<span class="cell w80">Returns true if <span class="nonterminal">M</span> cannot exactly match <em>string</em>.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span> ~= <em>string</em></span></span>
		<span class="cell w80">Returns true if <span class="nonterminal">M</span> matches some part of <em>string</em>.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span> !~= <em>string</em></span></span>
		<span class="cell w80">Returns true if <span class="nonterminal">M</span> cannot match any part of <em>string</em>.</span>
	</div>
</div><p/><div class="table inset"><div class="tableCaption">Rex string processing methods, where <span class="nonterminal">M</span> is a Rex pattern.</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span>.findFirstIn(<em>string</em>)</span></span>
		<span class="cell w80">Find and return the first matching substring of <em>string</em> as an <span class="code-inline">Option[MatchResult]</span>.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span>.findAllIn(<em>string</em>)</span></span>
		<span class="cell w80">Iterate over both matching and non-matching portions of <em>string</em>. This is the most general-purpose
		method of doing text manipulation in Rex.</span>
	</div>
	<div class="row"><span class="cell w10"><span class="code-inline"><span class="nonterminal">M</span>.replaceAllIn(<em>input</em>, <em>replacement</em>)</span></span>
		<span class="cell w80">Convenience method for performing simple replacement with a constant string.</span>
	</div>
</div><p/><p/><h1><a name="3"></a>Using Rex in Your Program</h1><p/><h2><a name="4"></a>Download Rex and Put It on Your Classpath</h2><p/>Get Rex from <em>https://github.com/KenMcDonald/rex</em> and put it on your project's classpath. As of Rex 0.7 initial
release, there is no prepackaged Rex artifact; this may change in the future.<p/><h2><a name="5"></a>Import Rex Into Your Code</h2><p/>You need at least one, and generally three, import statements to use Rex in your own code:<p/><div class="code-block"><span class="scalaLineComment">// This imports the basic constructors and predefined patterns.
</span><span class="scalaKeyword">import</span> com.digitaldoodles.rex._
<span class="scalaLineComment">// This imports a single (as of Rex 0,7) implicit conversion that allows strings to be used
</span><span class="scalaLineComment">// as literals in Rex expressions.
</span><span class="scalaKeyword">import</span> com.digitaldoodles.rex.Implicits._
<span class="scalaLineComment">// This imports objects that contain further predefined patterns; see the API documentation for details.
</span><span class="scalaKeyword">import</span> com.digitaldoodles.rex.patterns._
</div><p/>The second import, allowing strings to be converted to Rex literals, is a definite convenience, and in the
code examples in this document, we will normally assume the import of this implicit conversion.<p/><h1><a name="6"></a>Rex Basics: Literal Patterns and the Match and Occurs Operators</h1><p/>The simplest type of pattern in Rex is a <em>literal pattern</em>, which is formed with the <span class="code-inline">Lit</span> constructor function;
for example, <span class="code-inline">Lit(<span class="scalaString">&quot;bc&quot;</span>)</span> defines a literal pattern that matches the string &quot;bc&quot;.<p/>In addition, there are two different basic operators for matching a pattern against an input string. The <span class="code-inline">~~=</span> operator is
called the <em>match</em> operator, and returns true if and only if the pattern exactly matches the <em>entire</em> input string.
The <span class="code-inline">~=</span> operator is
called the <em>occurs</em> operator, and returns true if and only if the pattern exactly matches <em>some part</em> of the input string.<p/>For example, here are three matches that are all true; the part of the input string matched by the patterns is underlined.<p/><div class="code-block"><span class="scalaKeyword">val</span> bc = Lit(<span class="scalaString">&quot;bc&quot;</span>)
bc ~~= <span class="scalaString">&quot;<span class="underline">bc</span>&quot;</span>
bc ~= <span class="scalaString">&quot;<span class="underline">bc</span>&quot;</span>
bc ~= <span class="scalaString">&quot;a<span class="underline">bc</span>d&quot;</span>
</div><p/>The statement <span class="code-inline">Lit(<span class="scalaString">&quot;bc&quot;</span>) !~~= <span class="scalaString">&quot;abcd&quot;</span></span> is also true; <span class="code-inline">!~~=</span> means &quot;not ~~=&quot;, which is to say, &quot;does not match the
input string exactly&quot;. There is also <span class="code-inline">!~=</span> meaning, &quot;the pattern does not occur in the input string.&quot;<p/>There are much more sophisticated ways of matching against input strings, but the match and occurs operators, and their
negations, give us convenient ways of showing how Rex patterns match against input strings.<p/><h1><a name="7"></a>Building Rex Patterns</h1><p/>Now that you have an idea of what Rex can do and the basic terminology and operations, it's time to go into Rex in more
detail. This section discusses in detail how to build Rex patterns from the ground up, how to access predefined Rex
patterns, and how to combine matchers to produce a new matcher. Note that we use the terms 'pattern' and 'matcher'
interchangeably.<p/><h2><a name="8"></a>Rex Literals </h2><p/>You've already seen Rex literal matchers: <span class="code-inline">Lit(<span class="scalaString">&quot;123&quot;</span>)</span> produces a literal pattern that matches the string &quot;123&quot;.
However, there are a few more points to be made, especially if you have experience with a &quot;standard&quot; regular expression
engine.<p/><ul><li><span class="bold">Characters that have special meanings in normal regex engines do not need to be escaped.</span> In most regular
expression packages, including the Java regex engine that Rex uses, there are a large number of characters (including
+, *, (, ), and others) that need to be escaped (usually with a preceding backslash) to be used in a literal pattern.
<em>Rex does that for you automatically.</em>
</li><li><span class="bold">Conversely, characters that have special meanings in standard regexes do not have those meanings in Rex.</span> For
example, '.' in most regex engines will match (almost) any single character, but in Rex, <span class="code-inline">Lit(<span class="scalaString">&quot;.&quot;</span>)</span> simply
matches a period.
</li><li><span class="bold">You still need to be aware of string escaping.</span> <span class="code-inline">Lit(<span class="scalaString">&quot;\n&quot;</span>)</span> will not match a backslash followed by an
n, it will match a newline because the character sequence &quot;\n&quot; has a special meaning. To match a backslash followed by an
n, you can either do <span class="code-inline">Lit(<span class="scalaString">&quot;\\n&quot;</span>)</span> or <span class="code-inline">Lit(<span class="scalaString">&quot;&quot;</span><span class="scalaString">&quot;\n&quot;</span><span class="scalaString">&quot;&quot;</span>)</span>.
</li></ul><p/>
<h2><a name="9"></a>Character Classes</h2><p/>A <em>character class</em> is a pattern that matches a single character so long as it is in the set of characters recognized
by the character class. Rex provides two basic ways to define character classes, provides a number of predefined character
classes, and gives you a number of way to modify or combine existing character classes.<p/><h3><a name="10"></a>Basic Ways to Define Character Classes.</h3><p/>There are two ways to define new character classes:<p/><ul><li>The <span class="code-inline">CharSet(<em>string</em>)</span> construct defines a character class that contains the characters given
in the string argument.
<div class="note"><span class="bold">Note: </span>A CharSet cannot take an empty string as an argument. If you pass in an empty string, you will get
a runtime error.</div>
</li><li>The <span class="code-inline">CharRange(<em>char1, char2</em>)</span> construct defines a character class that contains all
characters between and inclusive of two character arguments the give the endpoints of a range of characters. Note
that the arguments are of type <span class="code-inline">Char</span>, not of type <span class="code-inline">String</span>
</li></ul><p/><h3><a name="11"></a>Predefined Character Classes</h3><p/>The <span class="code-inline">Chars</span> object provides a number of predefined character classes, such as <span class="code-inline">Chars.Lower</span> (lowercase
characters), <span class="code-inline">Chars.Digit</span> (0-9), <span class="code-inline">Chars.Punctuation</span> (punctuation characters), and many others.<p/>You can browse the API docs for a full list of values available in <span class="code-inline">Chars</span>, and use content assist in most
IDEs to help in completing the name for one of these values.<p/>As well, the subpackage <span class="code-inline">com.digitaldoodles.rex.patterns</span> provides a number of predefined patterns, and some
of the character classes defined in <span class="code-inline">Chars</span> are aliased there, for consistentcy within the <span class="code-inline">patterns</span>
offerings.<p/><h3><a name="12"></a>Character Class Extensions</h3><p/>You can form new characters classes by extending an existing class with new characters. This is done simply by
invoking appropriate methods on an existing characters class, in one of two ways:<p/><ol><li>The <span class="code-inline">charSet</span> and <span class="code-inline">charRange</span> methods are analogous to the <span class="code-inline">CharSet</span> and <span class="code-inline">CharRange</span>
functions, except that instead of creating from scratch a new class that encompasses a given set or range of characters, they
extend an existing class with a set or range of characters, to form a new class that will match a character if
it was in the invoking character class, or in the set or range of characters defined by the methods.<p/>It's really much easier to illustrate this by example than to explain it in prose.
<div class="code-block"><span class="scalaLineComment">// Match a lower-case vowel or any upper-case letter.
</span>CharSet(<span class="scalaString">&quot;aeiou&quot;</span>).charRange(<span class="scalaCharacter">'A'</span>, <span class="scalaCharacter">'Z'</span>)
<span class="scalaLineComment">// Match digits, or mathematical symbols, or a few variable names.
</span>CharRange(<span class="scalaCharacter">'0'</span>, <span class="scalaCharacter">'9'</span>).charSet(<span class="scalaString">&quot;+-*/^&quot;</span>).charSet(<span class="scalaString">&quot;xyz&quot;</span>)
</div>
</li><li>For each character class defined in
<span class="code-inline">Chars</span>, there is an identically named method available for Rex character class patterns that produces a new
character class which will match anything the original character class would match, or anything the character class
identified by the method name would match. For example:
<div class="code-block"><span class="scalaLineComment">// Matches any single digit.
</span>Chars.Digit
<span class="scalaLineComment">// Matches any single digit or lowercase letter.
</span>Chars.Digit.Lowercase
<span class="scalaLineComment">// Matches any single digit or lowercase letter or punctuation mark.
</span>Chars.Digit.Lowercase.Punctuation
<span class="scalaLineComment">// Matches digits, lowercase letters, or the basic arithmetic signs
</span>Chars.Digit.Lowercase.charSet(<span class="scalaString">&quot;+-*/&quot;</span>)
</div>
</li></ol><p/>These calls can be chained to any amount required, and of course you do not have to assemble a character class &quot;all
at one go&quot;. With a couple of special exceptions we'll discuss later, you can always extend an existing character class
as shown above.<p/><div class="note"><span class="bold">Note: </span>&quot;Extending&quot; a character class is purely functional; existing character classes are never modified, but rather new
ones are created.</div><p/><h3><a name="13"></a>Negated Character Classes</h3><p/>You can use the unary negation operator &quot;!&quot; to obtain a characters class that matches anything that is <em>not</em> matched
by the original class, and doesn't match anything that <em>is</em> matched by the original class. For example:<p/><div class="code-block"><span class="scalaLineComment">// Matches anything that isn't a punctuation mark.
</span>!Chars.Punctuation
<span class="scalaLineComment">// Match anything that isn't a letter or a period.
</span>!Chars.Lowercase.Uppercase.charSet(<span class="scalaString">&quot;.&quot;</span>)
</div><p/>It's important to note that a negated character class actually has an internal flag set that says, &quot;invert your
matching behavior with respect to the characters you are defined over&quot;. This means that if you extend a negated character
class, you will get a character class that <em>doesn't</em> match the characters you use in the extension. For example:
<div class="code-block"><span class="scalaLineComment">// Match anything except a digit.
</span><span class="scalaKeyword">val</span> noNumber = !Chars.Digit
<span class="scalaLineComment">// We can't &quot;add a digit back into the match&quot;.
</span>noNumber.charSet(<span class="scalaString">&quot;0&quot;</span>) !~~= <span class="scalaString">&quot;0&quot;</span>
<span class="scalaLineComment">// If we extend with something new, that will be included in the set of things that don't match.
</span>noNumber.Uppercase !~~= <span class="scalaString">&quot;A&quot;</span>
</div>
You can negate a negated character class, in which case you get back a regular, non-negated character class. In fact, for
any character class <span class="code-inline">C</span>, <span class="code-inline">C</span> and <span class="code-inline">!!C</span> will perform identically.<p/><h3><a name="14"></a>Character Class Instersection and Subtraction</h3><p/>The final thing you can do with character classes is to take the instersection of two of them (<span class="code-inline">/\</span>, or to subtract
one from another. These are really almost the same operation, as we'll see in a minute. They are somewhat different than
other character class operations, in that their result cannot be further operated on with character class operations; it
is actually an instance of the <span class="code-inline">FinalCharClass</span> Scala class. This is due to the way intersection and subtraction
are implemented in the underlying Java regex engine.<p/>Character class subtraction has probably the most obvious use case. Let's say you need to be able to match any punctuation
character <em>except</em> a period or comma. This will do it:<p/><div class="code-block"><span class="scalaKeyword">val</span> restrictedPunct: FinalCharClass = Chars.punctuation - CharSet(<span class="scalaString">&quot;,.&quot;</span>)
<span class="scalaLineComment">// Note that we cannot perform any more characters class operations on the result.
</span>restrictedPunct.Digit <span class="scalaLineComment">// COMPILE-TIME ERROR
</span></div><p/>More formally, <span class="code-inline"><span class="nonterminal">C1</span> - <span class="nonterminal">C2</span></span> matches a character if it is in <span class="nonterminal">C1</span> and not in <span class="nonterminal">C2</span>.<p/>On the other hand, character class intersection (<span class="code-inline"><span class="nonterminal">C1</span> /\ <span class="nonterminal">C2</span></span>) matches a character only if that character
is in both <span class="nonterminal">C1</span> <em>and</em> <span class="nonterminal">C2</span>. This is probably more useful when dealing with things like categories of
Unicode characters—something which I believe can be done with Java regexes, but which have not yet been implemented in Rex.<p/>We said before that intersection and subtraction were really almost the same operation. Here's why (where <span class="nonterminal">C1</span> and
<span class="nonterminal">C2</span> are character classes):<p/><ul><li><span class="code-inline"><span class="nonterminal">C1</span> - <span class="nonterminal">C2</span></span> is the same as <span class="code-inline"><span class="nonterminal">C1</span> /\ !<span class="nonterminal">C2</span></span> </li><li><span class="code-inline"><span class="nonterminal">C1</span> /\ <span class="nonterminal">C2</span></span> is the same as <span class="code-inline"><span class="nonterminal">C1</span> - !<span class="nonterminal">C2</span></span> </li></ul><p/><p/><h2><a name="15"></a>Repetition Operators</h2><p/><h3><a name="16"></a>Repetition Operator Basics</h3><p/>So far, the only things we can do are match a particular sequence of characters, or a single character that can be any
of a set of characters. Not very exciting. With repetition operators, we start to encounter the real power of regular
expressions and rex patterns.<p/>We'll begin with an example of the most common regular expression repetition operator:<p/><span class="code-inline black"><span class="scalaString">&quot;a&quot;</span> *&gt; 0 ~~= <span class="scalaString">&quot;aaaa&quot;</span>
</span><p/>The binary operator <span class="code-inline">*&gt;</span> is what is of interest here. It tries to match the input string by repeating its first
argument at least as many times as the number given in the second argument. The &quot;&gt;&quot; sign indicates this is a <em>greedy</em>
operator, which is something we'll get to in a bit. The &quot;*&quot; is used in all repetition operators; partly because it is the
basic repetition operator in standard regexes, and partly because * is the multiplication sign, and repetition is
simply matching multiple copies of something.<p/>Here are some more examples of simple repetition:<p/><div class="code-block"><span class="scalaString">&quot;a&quot;</span> *&gt; 3 !~~= <span class="scalaString">&quot;aa&quot;</span> <span class="scalaLineComment">// Fails because the pattern must match at least three a's.
</span><span class="scalaString">&quot;ab&quot;</span> *&gt; 0 ~~= <span class="scalaString">&quot;ababab&quot;</span>
<span class="scalaString">&quot;ab&quot;</span> *&gt; 0 !~~= <span class="scalaString">&quot;abababa&quot;</span> <span class="scalaLineComment">// Fails because the last &quot;a&quot; in the input cannot be matched by an &quot;ab&quot; in the pattern.
</span></div><p/>With repetition and character classes, we now have some real power; for example, <span class="code-inline">Chars.Digit *&gt; 1</span> will match any
unsigned integer.<p/>A slight variant allows the second argument of *&gt; to be a 2-tuple of integers: <span class="code-inline"><span class="scalaString">&quot;a&quot;</span> *&gt; (3, 5)</span> will match a sequence
of from three to five a's.<p/><h3><a name="17"></a>Repetition Strategies</h3><p/>If you ask someone to choose a piece of pie from a plate, they might choose different pieces for different reasons. A
polite person might choose the smallest piece, while a greedy (or simply hungry) person might choose the largest piece.
Similarly, repetition operators may choose to match with a smaller or larger part of the input string. Below is a brief
description of the different strategies, followed by examples.<p/><dl><dt>Greedy</dt><dd>The greedy repetition operator is <span class="code-inline">*&gt;</span>, where the &gt; sign is supposed to indicate more. The greedy operator will
match as many copies of its pattern as it can in the input string, <em>subject</em> to the caveat that it will not go
beyond the point that would cause the match to fail. Examples are coming up shortly.
</dd><dt>Non-Greedy</dt><dd>This is also sometimes called the <em>minimal</em> repetition strategy, and is implemented with the <span class="code-inline">*&lt;</span> operator, where the
&lt; sign is supposed to indicate the fact that this is a minimal match. A minimal repetition will match as little of the
input as possible, but will enlarge the amount it matches if necessary to make the match succeed.
</dd><dt>Possessive</dt><dd>The possessive operator is <span class="code-inline">*!</span>; the &quot;!&quot; is used because it is used in some languages to indicate a &quot;no-backtracking&quot;
cutpoint, which is more or less what possessive repetition is. Basically, the possessive operator is like the greedy
operator in that it will match as much of the input as possible, but unlike the greedy operator, it will not relinquish
any part of the input if that is necessary for the match to succeed; instead, it will let the match fail.<p/>The primary purpose of the possessive operator is to limit backtracking in pattern which would otherwise perform
unacceptably slowly. Unless you have a speed problem, you should probably avoid the possessive operator, as it can
make patterns more difficult to understand and debug.
</dd></dl><p/>All of the three repetition operators <span class="code-inline">*&gt;, *&lt;, and *!</span> can take either a single integer as argument, meaning, &quot;you
must match at least this many copies of your pattern&quot;, or a 2-tuple (<em>m, n</em>), meaning &quot;you must match at least <em>m</em>
but no more than <em>n</em> copies of your pattern&quot;.<p/>Here are some examples to make obvious how the different repetition operators work.<p/><div class="table inset"><div class="tableCaption">Examples of Different Types of Repetition (Greedy, Non-Greedy, and Possessive). Color of background
	indicates which part of the pattern matched which part of the input.</div>
	<div class="row"><span class="cell w80"><div class="code-block"><span class="scalaLineComment">// Notice that even though it is greedy, the left side of the pattern left an &quot;ab&quot; at the end of the
</span><span class="scalaLineComment">// string for the right side of the pattern to match, so that the overall pattern would succeed.
</span><span style="background-color: #AFF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*&gt;1</span> +~ <span style="background-color: #FAF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*&gt;1</span> ~~= <span class="scalaString">&quot;<span style="background-color: #AFF;">abab</span><span style="background-color: #FAF;">ab</span>&quot;</span></div>
		</span>
	</div>
	<div class="row"><span class="cell w80"><div class="code-block"><span class="scalaLineComment">//The left side of the pattern is non-greedy, and would prefer to match none of the input at all; however,
</span><span class="scalaLineComment">//the right side of the pattern can match at most two repetitions of &quot;ab&quot;, so the left side matches the
</span><span class="scalaLineComment">//first part of the input, up to the last two &quot;ab&quot;'s, so that the overall match can succeed.
</span><span style="background-color: #AFF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*&lt;0</span> +~ <span style="background-color: #FAF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*&gt;{1,2} </span> ~~= <span class="scalaString">&quot;<span style="background-color: #AFF;">abab</span><span style="background-color: #FAF;">abab</span>&quot;</span></div>
		</span>
	</div>
	<div class="row"><span class="cell w80"><div class="code-block"><span class="scalaLineComment">// The left side of the pattern is possessive, and matches as much of the pattern as it can, which
</span><span class="scalaLineComment">// in this case is all of it; however, this leaves nothing for the right side of the pattern to match,
</span><span class="scalaLineComment">// and it must match at least one &quot;ab&quot;, so the match fails. Contrast this with the example above where the
</span><span class="scalaLineComment">// left side of the pattern was greedy, and the match succeeded.
</span><span style="background-color: #AFF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*!</span> +~ <span style="background-color: #FAF;">CharSet(<span class="scalaString">&quot;ab&quot;</span>)*&gt;1</span> !~~= <span class="scalaString">&quot;<span style="background-color: #AFF;">ababab</span>&quot;</span></div>
		</span>
	</div>
</div><p/><h3><a name="18"></a>The Optional Operator</h3><p/>The &quot;optional&quot; operator makes a pattern optional; it is written as <span class="code-inline"><span class="nonterminal">A</span>.?</span>.
It is really just syntactic shorthand for <span class="code-inline"><span class="nonterminal">A</span> *&gt; (0, 1)</span>, but is useful not only because it cuts down some typing
in a common case, but also because it is much easier to read the meaning of a pattern when the optional operator is used.<p/>
<h2><a name="19"></a>Concatenation Operators</h2><p/>Concatenation operators simply assemble patterns into a sequence if each part of the sequence matches the input, one
after the other. The basic concatenation operator is <span class="code-inline">+~</span>; <span class="code-inline"><span class="nonterminal">A</span> +~ <span class="nonterminal">B</span></span> matches an input string
if <span class="nonterminal">A</span> matches from the beginning of the string to some point in the string, and <span class="nonterminal">B</span> matches from where <span class="nonterminal">A</span>
left off to the end of the string.<p/><div class="leftNote"><span class="bold">Why '+~'?</span> I originally used '&amp;' as the concatenation operator, but its precedence led to too many parentheses.
Next was '+', but since that's already used for string concatenation, it caused various problems. I finally settled on
'+~' because it is of appropriate precedence and '~' is (via Perl) associated with regexes.</div><p/>Using concatenation plus what we already know from above, we can finally start doing some interesting things. Here's
how to match an integer with an optional sign.<p/><div class="code-block"><span class="scalaKeyword">val</span> SignedInt = CharSet(<span class="scalaString">&quot;+-&quot;</span>).? +~ Chars.Digit*&gt;1
SignedInt ~~= <span class="scalaString">&quot;-1234&quot;</span>
</div><p/>With that defined, it's quite easy to build on it to obtain a pattern that matches numbers with a decimal
component.<p/><div class="code-block"><span class="scalaKeyword">val</span> SignedFloat = SignedInt +~ (<span class="scalaString">&quot;.&quot;</span> +  Chars.Digit*&gt;1).?
SignedFloat ~~= <span class="scalaString">&quot;3.14159&quot;</span>
SignedFloat ~~= <span class="scalaString">&quot;-100&quot;</span>
</div><p/>This is a big advantage Rex has over standard regexes—you can build complex patterns up bit by bit, making them both more
readable and more testable.<p/><h3><a name="20"></a>Convenience Concatenation Operators</h3><p/>In addition to the standard concatenation operator described above, Rex defines two &quot;convenience&quot; concatenation operators,
which can help a bit in the common case of matching strings separated by whitespace.<p/><span class="code-inline"><span class="nonterminal">A</span> +~~ <span class="nonterminal">B</span></span> matches an input string if <span class="nonterminal">A</span> matches the start of the input, there is at least
some whitespace, and then <span class="nonterminal">B</span> matches the rest of the input. So:<p/><div class="code-block"><span class="scalaString">&quot;a&quot;</span> +~~ <span class="scalaString">&quot;b&quot;</span> ~~= <span class="scalaString">&quot;a    b&quot;</span>
<span class="scalaString">&quot;a&quot;</span> +~~ <span class="scalaString">&quot;b&quot;</span> !~~= <span class="scalaString">&quot;ab&quot;</span>
</div><p/>By contrast, <span class="code-inline"><span class="nonterminal">A</span> +~~? <span class="nonterminal">B</span></span> matches an input string if <span class="nonterminal">A</span> matches the start of the input, there might be
some whitespace (but it isn't required), and then <span class="nonterminal">B</span> matches the rest of the input. Thus:<p/><div class="code-block"><span class="scalaString">&quot;a&quot;</span> +~~? <span class="scalaString">&quot;b&quot;</span> ~~= <span class="scalaString">&quot;a    b&quot;</span>
<span class="scalaString">&quot;a&quot;</span> +~~? <span class="scalaString">&quot;b&quot;</span> ~~= <span class="scalaString">&quot;ab&quot;</span>
</div><p/>
<h2><a name="21"></a>The Alternation Operator</h2><p/>A simple but extremely important operator for  building patterns is the alternation (<span class="code-inline">|</span>) operator. The expression
<span class="code-inline"><span class="nonterminal">A</span> | <span class="nonterminal">B</span> | <span class="nonterminal">C</span></span> will match an input string if <span class="nonterminal">A</span> matches it, <em>or</em> if <span class="nonterminal">B</span>
matches it, <em>or</em> if <span class="nonterminal">C</span> matches it, and the alternatives will be tried in that order.<p/>For example, the following matches numbers <em>or</em> letter sequences <em>or</em> &quot;line noise&quot;.<p/><div class="code-block"><span class="scalaKeyword">val</span> threeWay = <span style="background-color: #AFF;">Chars.Digit*&gt;1</span> | <span style="background-color: #FAF;">Chars.Alphabetic*&gt;1</span> | <span style="background-color: #FFA;">Chars.Punctuation*&gt;1</span>
threeWay ~~= <span class="scalaString">&quot;<span style="background-color: #AFF;">12345</span>&quot;</span>
threeWay ~~= <span class="scalaString">&quot;<span style="background-color: #FAF;">Hello</span>&quot;</span>
threeWay ~~= <span class="scalaString">&quot;<span style="background-color: #FFA;">#&amp;%^*^</span>&quot;</span>
threeWay !~~= <span class="scalaString">&quot;Hello, Number 1&quot;</span>
</div><p/>
<h2><a name="22"></a>Lookahead and Lookback Assertions</h2><p/>We're now getting to some less-used, but still very useful, parts of regular expression construction; <em>lookahead</em>
and <em>lookback</em> assertions. They're called assertions because, unlike other pattern-matching constructs, they
don't advance the match position (see belo) nor are they considered part of a match when extracting subparts of a match (which
will be discussed in a later section).<p/>Let's explore what this means in a bit more detail. At the bottom, all regular expression matching is done one character
at a time; a character from a pattern is matched against a character of the input, then a character from a pattern is
matched against the next character in the input, and so on. This means that, as a match is being calculated, there is a part of
the input that has been matched, and following that, a part of the input that has not yet been matched. The boundary
between the two of these is called the <em>match position</em>. The match position generally moves forward, but can move
backwards; this happens often with the alternation operator, when one alternative fails and the match position is
&quot;backed up&quot; so the next alternative can be tried. In general, a pattern starts matching at the current match position and,
if successful, advances the match position so that the next pattern starts matching further along the string.<p/>The lookahed and lookback assertions break this pattern somewhat. They do, of course, calculate matches one character
at a time. They also start matching at the current match position. However, <em>they do not change the match position</em>.
This is the reason for their names; they look, but don't actually change anything. However, if they fail, then the match
they are part of also fails.<p/>In the following, the lookahead/lookback assertions and what they match are shown with a colored border rather than a
colored background, to emphasize that they are not really &quot;part of&quot; the match, even though they must succeed for the
match to succeed.<p/><div class="code-block"><span style="border: 1px solid #FAF;">CharRange(<span class="scalaCharacter">'a'</span>, <span class="scalaCharacter">'b'</span>).&lt;&lt;</span> +~ <span style="background-color: #FAF;">Lit(<span class="scalaString">&quot;.&quot;</span>)</span> +~ <span style="border: 1px solid #FAF;">CharRange(<span class="scalaCharacter">'a'</span>, <span class="scalaCharacter">'b'</span>).&gt;&gt;</span> !~= <span class="scalaString">&quot;x.y&quot;</span>
<span style="border: 1px solid #FAF;">CharRange(<span class="scalaCharacter">'a'</span>, <span class="scalaCharacter">'b'</span>).&lt;&lt;</span> +~ <span style="background-color: #FAF;">Lit(<span class="scalaString">&quot;.&quot;</span>)</span> +~ <span style="border: 1px solid #FAF;">CharRange(<span class="scalaCharacter">'a'</span>, <span class="scalaCharacter">'b'</span>).&gt;&gt;</span> ~= <span class="scalaString">&quot;x.y <span style="border: 1px solid #FAF;">a</span><span style="background-color: #FAF;">.</span><span style="border: 1px solid #FAF;">b</span>&quot;</span>)
</div><p/><h3><a name="23"></a>Negative Lookahead/Lookback Assertions</h3><p/>In addition to the positive assertions shown above (<span class="code-inline">.&gt;&gt;</span> and <span class="code-inline">.&lt;&lt;</span>), there are <em>negative</em> lookahead/lookback
assertions <span class="code-inline">.!&gt;&gt;</span> and <span class="code-inline">.!&lt;&lt;</span>, which succeed if they <em>cannot</em> match after or before the match position.
This is important because, until now, the only way we've been able to say &quot;succeed in matching if something doesn't match&quot; has
been with negated character classes, which are only good for a single character. Such logic can't be implemented with &quot;normal&quot;
constructs such as literals, because &quot;normal&quot; pattern constructs advance the match position--and where would you move the
match position to for a construct that succeeded if it <em>didn't</em> match? However, since lookahead and lookback assertions
do not change the match position, they are free to implement negative logic.<p/>The example in the section on back-references uses this ability, albeit in a simplistic manner.<p/><h3><a name="24"></a>Restrictions on Lookahead/Lookback Assertions</h3><p/>Some regular expression engines place restrictions on what patterns can be turned into (especially) a lookback assertion.
This is due to the fact that lookback assertions must, in effect, make their patterns run in reverse. My understanding
is that the Java regex engine is fairly general and does not put too many restrictions on lookback assertions. However,
if you run into problems that seem to be related to this, you can do a number of things:<p/><ol><li>Isolate the lookback portion of your pattern as much as possible, and run it against simplified input to see
if the problem recurs.</li><li>Do a Google search for something like &quot;Java regular expression lookback&quot; and see what you can find.</li><li>Use the <span class="code-inline">.pattern</span> method on your pattern to get the Java regex, and post it with a question to
stackoverflow.com or somewhere similar.</li></ol><p/>
<h2><a name="25"></a>Back-References</h2><p/>The final tool for building patterns are <em>back-references</em>. Before getting into what back-references are and how to use
them, we must first touch on a subject that will be discussed in greater detail in a later section; <em>named groups</em>.<p/>A named group is simply a part of a pattern that has been assigned a name using the <span class="code-inline">name</span> method. When the pattern
participates in a match, the name given to the named part of the pattern may then be used to refer to whatever in the input
was matched by that part of the pattern. For example, in the pattern <span class="code-inline"><span class="scalaKeyword">val</span> complexMatcher = Number.SignedFloat.name(<span class="scalaString">&quot;re&quot;</span>) +~ (<span class="scalaString">&quot;-&quot;</span>|<span class="scalaString">&quot;+&quot;</span>).name(<span class="scalaString">&quot;sign&quot;</span>) +~ Number.SignedFloat.name(<span class="scalaString">&quot;im&quot;</span>) +~ <span class="scalaString">&quot;i&quot;</span></span>, the various parts of a complex number have been named so that if
a complex number is found by the pattern, its components may be extracted. Exactly how to do this is discussed in a later
section.<p/><div class="leftNote">Most regular expression engines enclose groups in parentheses, and identify a particular group by counting left parentheses
from the start of the regex. This is <em>extremely</em> error prone, and one of the primary reasons why standard regexes cannot
easily be composed into larger regexes. Python is one of the few languages that offers <em>named</em> groups, and my experience
with them was so positive that I don't even allow the creation of non-named groups in Rex. Rex has a feature for eliminating name
clashes, and keeps track of the correspondence between group name and group number automatically.</div><p/>To understand back-references, we'll look at a slightly more involved example, that also has the advantage of showing off
a major use of lookahead assertions. In most computer language, strings are quoted with double-quotes (&quot;), but in some
they can be quoted with single quotes ('). We want to build a single pattern that will match either type of string,
including handle the case of backslash-escaped quote characters within the string. The solution is below.<p/><div class="note"><span class="bold">Note: </span>The hinky backslashing is necessary because &quot; and \ themselves have special meanings within strings; so, for
example, we need to write '\\\&quot;' in a string so that the pattern will see '\&quot;'.</div><p/><div class="code-block"><span class="scalaLineComment">// A quote mark is just a &quot; or a '; we assign it the name &quot;quote&quot;.
</span><span class="scalaKeyword">val</span> quoteMark = CharSet(<span class="scalaString">&quot;\&quot;'&quot;</span>).name(<span class="scalaString">&quot;quote&quot;</span>)
<span class="scalaLineComment">// For the string body, we will take a backslash followed by any character; if we don't find that,
</span><span class="scalaLineComment">// we use a negative lookahead assertion to verify that the next character is <em>not</em> the same
</span><span class="scalaLineComment">// as the quote character, and then take that.
</span><span class="scalaKeyword">val</span> stringBody = (<span class="scalaString">&quot;\\&quot;</span> +~ Chars.Any | SameAs(<span class="scalaString">&quot;quote&quot;</span>).!&gt;&gt; +~ Chars.Any) *&gt;0
<span class="scalaLineComment">// A complete quoted string is just a quote mark, a string body, and an ending quote that is the
</span><span class="scalaLineComment">// same as the starting quote.
</span><span class="scalaKeyword">val</span> quotedString = quoteMark +~ stringBody +~ SameAs(<span class="scalaString">&quot;quote&quot;</span>)
quotedString ~~= <span class="scalaString">&quot;\&quot;Don't say \\\&quot;No\\\&quot;!\&quot;&quot;</span>
quotedString ~~= <span class="scalaString">&quot;'Don\\'t say No!'&quot;</span>
<span class="scalaLineComment">// This fails because the start quote mark is ' and the end quote mark is &quot;.
</span>quotedString !~~= <span class="scalaString">&quot;\&quot;Don\\'t say No!'&quot;</span>
</div><p/><h2><a name="26"></a>Flags</h2><p/>Regular expression engines typically have a number of flags that can be used to change details of how a pattern or subpattern
matches. During a career that has used regexes quite a bit, I've come to the conclusion that flags are error-prone and
should be avoided. The problem is that they came make the same regex behave in completely different manners, and if the
regex is constructed in one place but compiled (with flags) in another area of the code, it will not be at all obvious
what is causing the unexpected behavior.<p/>I believe that Rex is sufficiently flexible and powerful that there is simply no need for most of the flags found
in regex engines. The exception is with case sensitivity; it's easy to build a character class that matches both
upper and lower case, but not so easy to do the same with literals; for example, if you're processing HTML, you
probably want the literal &quot;span&quot; to match both &quot;span&quot; and &quot;SPAN&quot;.<p/>As a result Rex provides the methods <span class="code-inline">ASCIICaseSensitive</span>, <span class="code-inline">ASCIICaseInsensitive</span>, <span class="code-inline">UnicodeCaseSensitive</span>,
and <span class="code-inline">UnicodeCaseInsensitive</span>. When invoked on a Rex pattern, they make that pattern sensitive or insensitive to
either just the ASCII characters or to all Unicode characters.<p/>The default is case-sensitive. You can nest or combine patterns with different case sensitivities, for example<p/><div class="code-block">(<span class="scalaString">&quot;a&quot;</span>|<span class="scalaString">&quot;b&quot;</span>.UnicodeCaseSensitive).UnicodeCaseInsensitive *&gt;0
</div><p/>This matches sequences such as &quot;aAbabAAAbbAaAab&quot;. The rule is that the behavior of a pattern is determined by the innermost
flag declaration containing that pattern; so the &quot;b&quot; literal is case sensitive.<p/>This also means that in the pattern <span class="code-inline"><span class="nonterminal">A</span>.ASCIICaseInsensitive.ASCIICaseSensitive</span>, the pattern match of <span class="nonterminal">A</span>
will be case insensitive, as determined by the innermost flag.<p/>
<h1><a name="27"></a>Processing Text with Rex Patterns</h1><p/>The prior sections have mostly talked about how to construct Rex patterns. The only ways we've seen to use them are with
the matching and occurs operators, <span class="code-inline">~=</span>, <span class="code-inline">!~=</span>, <span class="code-inline">~~=</span>, and <span class="code-inline">!~~=</span>. While that kind of testing
can certainly be useful, it is limited. Fortunately, patterns permit much more powerful text processing; you can
search for text, extract parts of that text, replace that text with different text or a modified version of the same
text, and so on.<p/><h2><a name="28"></a>Extracting Sections of Input Using Named Patterns</h2><p/>A major part of this utility comes from the ability to assign names to parts of a Rex pattern, and then using that name,
to extract the section of the input matched by that part of the pattern. We've seen the use of named subpatterns (or
<em>groups</em> as they are commonly referred to) in the section on backreferences above, but now it's time to take a look
at the more general used of named groups.<p/>The code below does the following:<p/><ol><li>Creates a pattern to match complex numbers, with named groups. It uses the <span class="code-inline">SignedFloat</span> pattern that
is predefined in <span class="code-inline">rex.patterns</span> to make this job easier.</li><li>Uses that pattern and the <span class="code-inline">findFirstIn</span> method to find the first complex number in an input string
and match against it.</li><li>Processes the <span class="code-inline">Option[MatchResult]</span> object produced by the last step to extract the parts of the
complex number that was found.</li></ol><p/>The <span class="code-inline">MatchResult</span> type is the primary type for reporting the results of a match, but notice that <span class="code-inline">findFirstIn</span>
returns an <span class="code-inline">Option[MatchResult]</span>; this is necessary because there is no guarantee that <span class="code-inline">findFirstIn</span> can
find a match so as to produce a <span class="code-inline">MatchResult</span>. We'll discuss <span class="code-inline">findAllIn</span> shortly, which is more general.<p/><div class="code-block"><span class="scalaLineComment">// A complex is a float followed by a + or - followed by a float, followed by an &quot;i&quot;
</span><span class="scalaLineComment">// The two numeric parts and the sign are named for access.
</span><span class="scalaKeyword">val</span> complexMatcher = Number.SignedFloat.name(<span class="scalaString">&quot;re&quot;</span>) +~ (<span class="scalaString">&quot;-&quot;</span>|<span class="scalaString">&quot;+&quot;</span>).name(<span class="scalaString">&quot;sign&quot;</span>) +~ Number.SignedFloat.name(<span class="scalaString">&quot;im&quot;</span>) +~ <span class="scalaString">&quot;i&quot;</span>
<span class="scalaBlockComment">/** Match against a floating-point complex number and print the result. */</span>
<span class="scalaKeyword">val</span> found: Option[MatchResult] = complexMatcher.findFirstIn(<span class="scalaString">&quot;3.2+4.5i&quot;</span>)
<span class="scalaKeyword">val</span> complex = found <span class="scalaKeyword">match</span> {
	<span class="scalaKeyword">case</span> None =&gt; None
	<span class="scalaKeyword">case</span> Some(mr) =&gt; mr(<span class="scalaString">&quot;re&quot;</span>) + <span class="scalaString">&quot; &quot;</span> + mr(<span class="scalaString">&quot;sign&quot;</span>) + <span class="scalaString">&quot; &quot;</span> + mr(<span class="scalaString">&quot;im&quot;</span>) + <span class="scalaString">&quot;i&quot;</span>
}
assert(complex === <span class="scalaString">&quot;3.2 + 4.5i&quot;</span>)
</div><p/>Hopefully this code is fairly easy to read and understand. It may be helpful to clarify or repeat a few points:<p/><ol><li>Objects of type <span class="code-inline">MatchResult</span> are what contain information about a match.</li><li>Sections of a pattern are named using the <span class="code-inline">name(<em>nameString</em>)</span> method.</li><li>To extract parts of the input corresponding to named portions of the pattern, treat the <span class="code-inline">MatchResult</span>
as a <span class="code-inline">Map[String, String]</span> instance, and simply say <span class="code-inline">someMatchResult(<em>patternSectionName</em>)</span>.</li><li>Although not shown above, use the <span class="code-inline">string</span> method to get the entire portion of the
input that was matched by the pattern.</li></ol><p/><h2><a name="29"></a>Avoiding Name Clashes with Hierarchical Names</h2><p/>One problem with naming subgroups in Rex patterns, is that one may find oneself with a name clash when trying to combine
two patterns that both use the same name somewhere within them. Rex will throw a runtime error if you do this. Fortunately,
Rex provides an easy way to fix this, via <em>hierarchical</em> (or dotted) names.<p/>Let's say <span class="nonterminal">A</span> is a Rex pattern containing several named sections. If we now produce a new, named version of <span class="nonterminal">A</span>
by saying <span class="code-inline"><span class="nonterminal">A</span>.name(<span class="scalaString">&quot;A.&quot;</span>)</span>, then <span class="nonterminal">A</span> will receive the name &quot;A&quot;, and <em>all names of subpatterns of <span class="nonterminal">A</span>
will receive the prefix &quot;A.&quot;</em>. This only occurs when we pass to the <span class="code-inline">name</span> method a name ending with a &quot;.&quot;.<p/>To see this in action, let's continue on with the complex number example shown previously, and allow it to match
two complex numbers simultaneously. Since the complex number pattern has named subpatterns, we'll need to use the
hierarchical naming trick to avoid names clashes.<p/><div class="code-block"><span class="scalaKeyword">val</span> doubleMatcher = complexMatcher.name(<span class="scalaString">&quot;num1.&quot;</span>) +~~ complexMatcher.name(<span class="scalaString">&quot;num2.&quot;</span>)
<span class="scalaKeyword">val</span> doubleResult = doubleMatcher.findFirstIn(<span class="scalaString">&quot;1+2i 3+4i&quot;</span>).get
assert(doubleResult(<span class="scalaString">&quot;num1.re&quot;</span>) === <span class="scalaString">&quot;1&quot;</span>)
assert(doubleResult(<span class="scalaString">&quot;num2.im&quot;</span>) === <span class="scalaString">&quot;4&quot;</span>)
</div><p/><h2><a name="30"></a>Processing All Matches in an Input String</h2><p/>Most regex packages give you some way of iterating through all sections of an input string a given pattern matches.
However, I've often found this frustrating, as my experience has often been that you want information about both the
matched and the non-matched portions of the input, and Rex provides this by default.<p/>The key method for iterating through matches in a string is <span class="code-inline">findAllIn</span>, which returns an object of type
<span class="code-inline">Iterator[MatchResult]</span>. All <span class="code-inline">MatchResult</span> instances have a boolean value <span class="code-inline">matched</span>, which is
true if the <span class="code-inline">MatchResult</span> represents a section of input that was matched by the invoking pattern, and false
if the <span class="code-inline">MatchResult</span> represesents a section of the input that could <em>not</em> be matched by the invoking
pattern. How this works is made clear by the example below.<p/><div class="code-block">assert( (for(m &lt;- Lit(<span class="scalaString">&quot;a&quot;</span>).findAllIn(<span class="scalaString">&quot;aabbabb&quot;</span>)) yield m.string).mkString(<span class="scalaString">&quot;&quot;</span>) === <span class="scalaString">&quot;aabbabb&quot;</span>)
assert( (for(m &lt;- Lit(<span class="scalaString">&quot;a&quot;</span>).findAllIn(<span class="scalaString">&quot;aabbabb&quot;</span>) <span class="scalaKeyword">if</span> (m.matched)) yield m.string).mkString(<span class="scalaString">&quot;&quot;</span>) === <span class="scalaString">&quot;aaa&quot;</span>)
assert( (for(m &lt;- Lit(<span class="scalaString">&quot;a&quot;</span>).findAllIn(<span class="scalaString">&quot;aabbabb&quot;</span>) <span class="scalaKeyword">if</span> (!m.matched)) yield m.string).mkString(<span class="scalaString">&quot;&quot;</span>) === <span class="scalaString">&quot;bbbb&quot;</span>)
</div><p/>For any given <span class="code-inline">MatchResult</span> <span class="nonterminal">M</span>, if <span class="code-inline"><span class="nonterminal">M</span>.matched</span> is true then sections of input matching named
subpatterns may be extracted using the <span class="code-inline"><span class="nonterminal">M</span>(<em>groupName</em>)</span> convention, whereas if <span class="code-inline"><span class="nonterminal">M</span>.matched</span> is
false, the only operation you can perform to obtain the (non-)matching input is <span class="code-inline"><span class="nonterminal">M</span>.string</span>.<p/><h2><a name="31"></a>Simple String Replacement</h2><p/><span class="code-inline">findAllIn</span> allows you to perform very complex string manipulation. However, if you simply need to replace
parts of the input string with a constant string, see the <span class="code-inline">replaceAllIn</span> API, as it will be significantly
simpler.<p/><h2><a name="32"></a>The Tokenizer Class</h2><p/>Rex provides a <span class="code-inline">Tokenizer</span> class, so-called because it can be used to process tokens from computer code in
different ways--in fact, I wrote it primarily so I could provide bolding and colorization to the Scala code in this
document. However, I've certainly found the general concept useful in the past, so included it in Rex.<p/>A <span class="code-inline">Tokenizer</span> operates simply by taking a number of Rex patterns which have associated functions with them, and
iterating through in input string, applying to each subsection of the input matched by one of the provided patterns the
function that is associated with that pattern. A default function is used to process sections of the input that are not
matched by any of the provided patterns.<p/>The API docs have more information. As I want to get this version of Rex out before the weekend, I'm simply going to
show first the tokenizer in the test suite, and then the tokenizer I constructed to process Scala code for this document.<p/><div class="code-block"><span class="scalaKeyword">val</span> t = <span class="scalaKeyword">new</span> Tokenizer(
	(mr: MatchResult) =&gt; <span class="scalaString">&quot;?&quot;</span>,
	Seq(
		Lit(<span class="scalaString">&quot;a&quot;</span>) -&gt; ((mr: MatchResult) =&gt; <span class="scalaString">&quot;1&quot;</span>),
		Lit(<span class="scalaString">&quot;b&quot;</span>) -&gt; ((mr: MatchResult) =&gt; <span class="scalaString">&quot;2&quot;</span>)
	)
)
assert(t.tokenize(<span class="scalaString">&quot;fabaabbc&quot;</span>).mkString === <span class="scalaString">&quot;?121122?&quot;</span>)
</div><p/><div class="code-block"><span class="scalaKeyword">val</span> tripleQuotedString = <span class="scalaString">&quot;\&quot;\&quot;\&quot;&quot;</span> +~ Chars.Any*&lt;0 +~ <span class="scalaString">&quot;\&quot;\&quot;\&quot;&quot;</span><p/><span class="scalaKeyword">val</span> htmlTag = <span class="scalaString">&quot;&lt;&quot;</span> +~ Chars.Any*&lt;0 +~ <span class="scalaString">&quot;&gt;&quot;</span>
<span class="scalaKeyword">val</span> singleQuotedString = <span class="scalaString">&quot;&amp;quot;&quot;</span> +~ ((<span class="scalaString">&quot;\\&quot;</span> +~ Chars.Any) | !CharSet(<span class="scalaString">&quot;\&quot;&quot;</span>) | htmlTag)*&lt;0 +~ <span class="scalaString">&quot;&amp;quot;&quot;</span>
<span class="scalaKeyword">val</span> keyword = Word.Boundary +~ (<span class="scalaString">&quot;if&quot;</span>|<span class="scalaString">&quot;then&quot;</span>|<span class="scalaString">&quot;else&quot;</span>|<span class="scalaString">&quot;def&quot;</span>|<span class="scalaString">&quot;class&quot;</span>|<span class="scalaString">&quot;public&quot;</span>|<span class="scalaString">&quot;private&quot;</span>|<span class="scalaString">&quot;implicit&quot;</span>|<span class="scalaString">&quot;lazy&quot;</span>|
	<span class="scalaString">&quot;extends&quot;</span>|<span class="scalaString">&quot;with&quot;</span>|<span class="scalaString">&quot;case&quot;</span>|<span class="scalaString">&quot;final&quot;</span>|<span class="scalaString">&quot;sealed&quot;</span>|<span class="scalaString">&quot;while&quot;</span>|<span class="scalaString">&quot;repeat&quot;</span>|<span class="scalaString">&quot;until&quot;</span>|<span class="scalaString">&quot;import&quot;</span>|<span class="scalaString">&quot;package&quot;</span>|
	<span class="scalaString">&quot;new&quot;</span>|<span class="scalaString">&quot;override&quot;</span>|<span class="scalaString">&quot;try&quot;</span>|<span class="scalaString">&quot;catch&quot;</span>|<span class="scalaString">&quot;finally&quot;</span>|<span class="scalaString">&quot;throw&quot;</span>|<span class="scalaString">&quot;match&quot;</span>|<span class="scalaString">&quot;val&quot;</span>|<span class="scalaString">&quot;var&quot;</span>) +~ Word.Boundary
<span class="scalaKeyword">val</span> lineComment = <span class="scalaString">&quot;//&quot;</span> +~ Chars.Any*&lt;0 +~ CharSet(<span class="scalaString">&quot;\n\r&quot;</span>)
<span class="scalaKeyword">val</span> blockComment = <span class="scalaString">&quot;/*&quot;</span> +~ Chars.Any*&lt;0 +~ <span class="scalaString">&quot;*/&quot;</span>
<span class="scalaKeyword">val</span> character = <span class="scalaString">&quot;'&quot;</span> +~ (!CharSet(<span class="scalaString">&quot;'&quot;</span>) | <span class="scalaString">&quot;&quot;</span><span class="scalaString">&quot;\'&quot;</span><span class="scalaString">&quot;&quot;</span>) +~ <span class="scalaString">&quot;'&quot;</span><p/><span class="scalaKeyword">def</span> wrapWithClass(clss: String, content: String) = <span class="scalaString">&quot;&quot;</span><span class="scalaString">&quot;&lt;span class=&quot;</span>%s<span class="scalaString">&quot;&gt;%s&lt;/span&gt;&quot;</span><span class="scalaString">&quot;&quot;</span> format (clss, content)<p/><span class="scalaKeyword">val</span> scalaHighlighter = <span class="scalaKeyword">new</span> Tokenizer[String](
	(mr: MatchResult) =&gt; mr.string,
	Seq(
		htmlTag -&gt; (mr =&gt; mr.string),
		tripleQuotedString -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaString&quot;</span>, mr.string)),
		singleQuotedString -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaString&quot;</span>, mr.string)),
		keyword -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaKeyword&quot;</span>, mr.string)),
		blockComment -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaBlockComment&quot;</span>, mr.string)),
		lineComment -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaLineComment&quot;</span>, mr.string)),
		character -&gt; (mr =&gt; wrapWithClass(<span class="scalaString">&quot;scalaCharacter&quot;</span>, mr.string))
	)
)
</div><p/>
		</body>
		</html>